:PROPERTIES:
:ID:       05c33001-9ec5-4e2d-ba28-0fc386486870
:END:
#+title: game tree
* basics
a game tree is how we express the set of moves either player can do, at the end state of any game a score is perscribed to the players, indicating wether they have won and by how much, so in like poker that could be the amount of money gained and lost by the players in a round and in chess it could just be 1 for win -1 for loose and 0 for stalemate,
games where the numberic values for how well players are performing sum to zero are called [[id:7171bcf3-82f5-4c9a-a7bd-a8769fc7f772][zero sum]] games

when dealing with random events on a game tree we express this with another player, chance whos actions have probabilities and gains no rewards

game trees are time consuming to draw and not particularly helpful, though computers can make graphs of them very fast and traverse them well, rendering them isnt always amazing though

if you want to make a thing use [[id:a1c85953-c0b9-4a8f-a4ac-341ae2945ea7][normal form]]

* imperfect information
with imperfect information games become no longer solveable and we cannot make a refined strategy for the best play style, in 21 we can make a winning set of moves easily, wheras in poker, this cannot be done as we dont know what the other player is doing
with chance we cannot make a certain best choice, but we can make a strategy that has the highest probability of being the best choice

* navagating
generally we aim to manage solving a game tree by navagating the best course through it, what we could do is have it go all the way to the end of the game and pick the choice that gives us the best chance of winning or the opponent the least chance of winning, these are the same thing really,,,,

generally though this sucks balls and makes me want to kill myself, so we should figure out another way around this
we can minimise the number of nodes we look at through a number of methods

1) [[id:03435114-7914-4a09-8cd0-2758b24eb1f2][alpha beta pruning]]
2) others

now we still might have a very large game tree so a good solution is to try and stop at a point, but we need to return a value so we use [[id:5191f1c1-8bcb-4a4b-ad0e-31d226099aac][node evaluation]] which helps,

navigating trees and using min max doesnt get us everywhere though, much like with go where the board is large and the number of moves is high, and there are like no methods of evaluating the board state, so we need another approach
